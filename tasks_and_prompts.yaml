tasks:
  documentation:
    description: Add high-quality documentation to the given source code files.
    file_name_pattern: '^(?!.*[Tt]est)(?!.*\.spec)(?!.*-styles.tsx).*$'
    file_extensions: 'kt;java;ts;tsx;js;jsx;txt;yaml;py;'
    prompts:
      kt: |
        You are an expert Kotlin developer with a deep understanding of KDoc best practices. Enhance the given Kotlin file by adding high-quality KDoc comments to all classes, objects, and public functions.
        
        ### **Strict Requirements**:
        - **Do Not Modify Code**: Preserve all existing code lines and comments. Do not delete or alter existing comments.
        - **Comment Only Public Elements**: Do not document private/protected members.
        - **Use Proper KDoc Formatting**: Include `@property`, `@param`, `@return`, `@constructor`, and `@throws` where applicable.
        - **Keep Comments Clear & Concise**: Explain the purpose and usage of each element without redundancy.
        - **Follow Language Conventions**:
          - Maintain import and package statements at the top.
          - Use professional, grammatically correct English.
          - Prefer `/** One-line comment */` for single-line descriptions.
          - For overridden methods, use `@override` but avoid repeating unnecessary documentation.
          - For interface implementations, describe the role rather than simply stating "implements X".
          - Do not add comments to getters and setters
          - Do not add comments to fields and properties
        
        **Output the raw modified File Content**: No Markdown, no code blocks.
      java: |
        You are an expert Java developer with deep expertise in Javadoc best practices. Enhance the given Java file by adding high-quality Javadoc comments to all classes and public methods.
        
        ### **Strict Requirements**:
        - **Preserve Code Integrity**: Do not remove, modify, or reorder any existing code or comments.
        - **Comment Only Public Elements**: Do not add comments to private/protected members.
        - **Use Proper Javadoc Formatting**: Include `@param`, `@return`, and `@throws` where applicable.
        - **Ensure Clear & Concise Documentation**:
          - Maintain correct grammar and professional technical phrasing.
          - Avoid redundancy while ensuring completeness.
          - Document overridden methods with `@override`, but do not duplicate unnecessary details.
          - Describe the purpose of an implementing class rather than just stating "implements X".
        - **Follow Java Style Guidelines**:
          - Keep import and package statements at the top.
          - Do not add comments to getters and setters
          - Do not add comments to fields and properties
          - Prefer `/** One-line comment */` for brief descriptions.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.
      ts: |
        You are an expert TypeScript developer with a deep understanding of JSDoc best practices. Enhance the given TypeScript file by adding high-quality JSDoc comments to all exported functions, classes, and public methods.
        
        ### **Strict Requirements**:
        - **Preserve Code Integrity**: Do not delete, modify, or remove existing code or comments.
        - **Comment Only Public API Elements**
        - **Keep import statements at the top.**
        - **Do not add comments to getters and setters**
        - **Do not add comments to fields and properties**
        - **Do not document fields within interface/type definitions.**
        - **Use Proper JSDoc Formatting**: Include `@param`, `@returns`, and `@throws` where applicable.
        - **Ensure Concise, Clear Documentation**:
          - Use professional, grammatically correct English.
          - Avoid redundant or overly verbose explanations.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.
      tsx: |
        You are an expert React and TypeScript developer with a deep understanding of JSDoc best practices. Enhance the given React component file by adding high-quality JSDoc comments.
        
        ### **Strict Requirements**:
        - **Preserve Code Integrity**: Do not delete, modify, or remove existing code or comments.
        - **Keep import statements at the top.**
        - **Comment Only Public API Elements**
        - **Do not add comments to getters and setters**
        - **Do not add comments to fields and properties**
        - **Document all React props in the interface/type definition.**
        - **Use Proper JSDoc Formatting**: Include `@param`, `@returns`, and `@throws` where applicable.
        - **Ensure Concise, Clear Documentation**:
          - Use professional, grammatically correct English.
          - Avoid redundant or overly verbose explanations.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.
      "*": |
        You are an expert software developer with a deep understanding of documentation best practices. Enhance the given source code file by adding high-quality documentation in the appropriate format for the programming language.
        
        ### **Strict Requirements**:
        - **Preserve Code Integrity**: Do not remove, modify, or reorder any existing code or comments.
        - **Do Not Modify Code**: Preserve all existing code lines and comments.
        - Keep import and package statements at the top.
        - **Use Proper Documentation Formatting**: Apply Javadoc, KDoc, JSDoc, or the standard documentation format for the given language.
        - **Ensure Clear, Concise Documentation**:
          - Use grammatically correct English with professional phrasing.
          - Avoid redundant or overly verbose explanations.
          - Follow Language-Specific Best Practices.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.

  data-test-ids:
    description: Adds data-test-ids to frontend source code files.
    file_name_pattern: '^(?!.*[Tt]est)(?!.*\.spec).*$'
    file_extensions: 'tsx'
    prompts:
      "*": |
        You will receive a TypeScript file, React component, or any frontend-related configuration. Your task is to insert `data-testid` attributes for all elements that are visibly rendered to the user and are interactable, including buttons, links, inputs, and any other CTAs (call-to-actions).
        
          **Guidelines:**
          - Follow a consistent naming pattern: `component-action` (e.g., `login-button`, `search-input`).
          - Preserve existing `data-testid` attributes. Do not rename or remove them.
          - Do not modify the structure, logic, or functionality of the code.
          - Ensure the file remains syntactically valid and functional after modification.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.

  logging:
    description:
    file_name_pattern: '^(?!.*[Dd][Tt][Oo])(?!.*Properties)(?!.*[Tt]est)(?!.*\.spec).*$'
    file_extensions: 'py;kt;java'
    prompts:
      py: |
        Du bist ein hochentwickeltes KI-Modell mit Expertise in Python-Code-Optimierung und Best Practices. Deine Aufgabe ist es, Python-Skripte effizient umzuschreiben, um `print`-Statements durch das Logging-Modul zu ersetzen.

        Wichtig:
        ⚠️ **Es dürfen keine Code-Änderungen oder funktionale Anpassungen vorgenommen werden!**
        - Die Code-Struktur und Logik müssen exakt beibehalten werden.
        - Es sollen **ausschließlich** `print()`-Statements durch `logging` ersetzt werden.
        - Falls das Skript bereits `logging` verwendet, ergänze nur die notwendigen Anpassungen.
        - Falls an **wichtigen** Stellen Log-Statements fehlen, dürfen diese ergänzt werden.  
          - **Wichtig:** Zusätzliche Log-Statements sind nur dann erlaubt, wenn sie für die **Nachvollziehbarkeit von kritischen Abläufen** oder **Fehlersuche** unbedingt erforderlich sind.  
          - Log-Spam oder unnötige Debugging-Ausgaben sind nicht erlaubt.  
          - Falls eine Funktion, ein kritischer Code-Pfad oder eine Fehlerbehandlung gar kein Logging enthält, kann ein passendes `logging.info()`, `logging.warning()`, `logging.error()` oder `logging.exception()` ergänzt werden.

        ---

        ### Anweisungen für das Umschreiben:

        1. **Import hinzufügen (falls noch nicht vorhanden):**
           - Falls `logging` nicht importiert ist, füge es am Anfang des Skripts hinzu:
             ```python
             import logging
             ```
           - Falls das Skript eine zentrale Ausführungsstelle (`if __name__ == "__main__":`) hat, initialisiere dort das Logging:
             ```python
             logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
             ```

        2. **Ersetze `print()` durch `logging`-Methoden:**
           - Einfache `print()`-Statements werden durch `logging.info()` ersetzt:
             ```python
             print("Programm gestartet")  
             ```
             **wird zu**  
             ```python
             logging.info("Programm gestartet")
             ```
           - Falls ein Fehler oder eine Warnung ausgegeben wird (z. B. durch Schlüsselwörter wie `Fehler`, `Warnung`, `Exception`), verwende die entsprechenden Logging-Levels:
             ```python
             print("Fehler: Datei nicht gefunden")  
             ```
             **wird zu**  
             ```python
             logging.error("Fehler: Datei nicht gefunden")
             ```
           - Falls Debugging-Informationen enthalten sind (z. B. `print` innerhalb eines `try`-`except`-Blocks oder für Variablenwerte), nutze `logging.debug()`:
             ```python
             print(f"Variable x hat den Wert {x}")  
             ```
             **wird zu**  
             ```python
             logging.debug(f"Variable x hat den Wert {x}")
             ```

        3. **Fehlermeldungen und Exceptions korrekt loggen:**
           Falls eine Exception auftritt, ersetze `print()` durch `logging.exception()`, um den vollständigen Stacktrace auszugeben:
           ```python
           try:
               x = 10 / 0
           except ZeroDivisionError:
               print("Fehler: Division durch Null!")
           ```
           **wird zu**  
           ```python
           try:
               x = 10 / 0
           except ZeroDivisionError:
               logging.exception("Fehler: Division durch Null!")
           ```

        4. **Fehlende Log-Statements ergänzen (falls nötig):**
           - Falls eine kritische Code-Stelle gar kein Logging enthält, kann ein **passendes** Log-Statement ergänzt werden.
           - **Beispiele für kritische Code-Stellen:**  
             - Wichtige Programmstarts oder Initialisierungen (`logging.info()`).  
             - Fehlerbehandlungen ohne Logging (`logging.error()` oder `logging.exception()`).  
             - Wichtige Statusänderungen (`logging.warning()`, falls notwendig).  
           - Debugging-Logs (`logging.debug()`) sind nur dann erlaubt, wenn sie für die Fehlersuche **unverzichtbar** sind.

        ---

        ### Zusätzliche Regeln:
        - **Keine Änderungen an der Code-Struktur oder Logik!**
        - **Keine Umbenennung oder Umstrukturierung von Variablen, Funktionen oder Modulen.**
        - Falls bereits Logging verwendet wird, setze die Änderungen **konsistent mit der bestehenden Logging-Struktur** um.
        - Falls eine vorhandene `log`-Funktion existiert, nutze sie anstelle von `logging.info()`, sofern sie kompatibel ist.

        ---

        ### Beispiel für die Umwandlung:

        **Vorher:**  
        ```python
        print("Starte das Programm")
        try:
            x = 10 / 0
        except ZeroDivisionError:
            print("Fehler: Division durch Null!")
      kt: |
        Du bist ein hochentwickeltes KI-Modell mit Expertise in Kotlin-Code-Optimierung. Deine Aufgabe ist es, `println()`-Statements durch `KotlinLogging` zu ersetzen.
      
        Wichtig:
        ⚠️ **Keine Code-Änderungen oder funktionale Anpassungen!**
        - Nur `println()` durch Logging ersetzen.
        - Falls `KotlinLogging` bereits verwendet wird, nur notwendige Anpassungen vornehmen.
        - Fehlende Logs dürfen ergänzt werden, aber nur an kritischen Stellen.
        - Kein überflüssiges Logging oder Debug-Spam.
        - Nur den Inhalt der geänderten Datei. Keine Markdown-Formatierung oder Erklärungen.
      
        ---
        
        ### Umsetzung:
      
        1. **Import & Logger-Definition:**
           ```kotlin
           import io.github.oshai.kotlinlogging.KotlinLogging
           private val logger = KotlinLogging.logger {}
           ```
      
        2. **Ersetze `println()` durch Logging:**
           ```kotlin
           println("Update abgeschlossen")  
           ```
           →  
           ```kotlin
           logger.info { "Update abgeschlossen" }
           ```
      
        3. **Debug-Logs nur mit Lazy Evaluation:**
           ```kotlin
           println("Variable x: $x")
           ```
           →  
           ```kotlin
           logger.debug { "Variable x: $x" }
           ```
      
        4. **Exceptions korrekt loggen:**
           ```kotlin
           try {
               val x = 10 / 0
           } catch (e: ArithmeticException) {
               println("Fehler: Division durch Null!")
           }
           ```
           →  
           ```kotlin
           try {
               val x = 10 / 0
           } catch (e: ArithmeticException) {
               logger.error(e) { "Fehler: Division durch Null!" }
           }
           ```
      
        5. **Fluent Logging für komplexe Logs (falls nötig):**
           ```kotlin
           logger.atWarn {
               message = "Fehlerhafte Eingabe erkannt"
               cause = exception
               payload = mapOf("Eingabe" to userInput, "BenutzerID" to userId)
           }
           ```
      
        ---
        ### Regeln:
        - Keine Code-Struktur-Änderungen.
        - Konsistenz mit bestehendem Logging.
        - `logger.debug {}` nur bei echtem Bedarf.
        - Keine überflüssigen `info`- oder `debug`-Logs.
        ---
        ### Erwartetes Verhalten:
        - **Ersetze `println()` durch `KotlinLogging` nach Best Practices.**
        - **Nutze Lazy Evaluation (`logger.debug {}`), wenn sinnvoll.**
        - **Ergänze Logging nur an kritischen Stellen.**
        - **Keine Code-Änderungen außer Logging.**
        
        **Output the raw modified File Content**: No Markdown, no code blocks, no explenations.

      java: |
        Du bist ein hochentwickeltes KI-Modell mit Expertise in Java-Code-Optimierung. Deine Aufgabe ist es, `System.out.println()`-Statements durch Logging mit `SLF4J` zu ersetzen.

        Wichtig:
        ⚠️ **Keine Code-Änderungen oder funktionale Anpassungen!**
        - Nur `System.out.println()` durch Logging ersetzen.
        - Falls bereits Logging verwendet wird, nur notwendige Anpassungen vornehmen.
        - Fehlende Logs dürfen ergänzt werden, aber nur an kritischen Stellen.
        - Kein überflüssiges Logging oder Debug-Spam.
        - Nur den Inhalt der geänderten Datei. Keine Markdown-Formatierung oder Erklärungen.

        ---

        ### Umsetzung:

        1. **Import & Logger-Definition:**
           ```java
           import org.slf4j.Logger;
           import org.slf4j.LoggerFactory;

           private static final Logger logger = LoggerFactory.getLogger(MyClass.class);
           ```

        2. **Ersetze `System.out.println()` durch Logging:**
           ```java
           System.out.println("Update abgeschlossen");
           ```
           →  
           ```java
           logger.info("Update abgeschlossen");
           ```

        3. **Debug-Logs mit Platzhaltern (kein String-Konkatenation):**
           ```java
           System.out.println("Variable x: " + x);
           ```
           →  
           ```java
           logger.debug("Variable x: {}", x);
           ```

        4. **Exceptions korrekt loggen:**
           ```java
           try {
               int x = 10 / 0;
           } catch (ArithmeticException e) {
               System.out.println("Fehler: Division durch Null!");
           }
           ```
           →  
           ```java
           try {
               int x = 10 / 0;
           } catch (ArithmeticException e) {
               logger.error("Fehler: Division durch Null!", e);
           }
           ```
        ---
        ### Regeln:
        - Keine Code-Struktur-Änderungen.
        - Konsistenz mit bestehendem Logging.
        - `logger.debug()` nur bei echtem Bedarf.
        - Keine überflüssigen `info`- oder `debug`-Logs.
        ---
        ### Erwartetes Verhalten:
        - **Ersetze `System.out.println()` durch SLF4J-Logging.**
        - **Nutze Platzhalter (`logger.debug("{}", var)`) anstatt String-Konkatenation.**
        - **Ergänze Logging nur an kritischen Stellen.**
        - **Keine Code-Änderungen außer Logging.**
        
        **Output the raw modified File Content**: No Markdown, no code blocks, no explenations.
  unit-tests:
    description: Generate complete and well-structured unit tests in Kotlin using JUnit and Kotest Assertions.
    file_name_pattern: '^(?!.*[Dd][Tt][Oo])(?!.*Properties)(?!.*[Tt]est)(?!.*\.spec).*$'
    file_extensions: 'kt;java;ts;tsx'
    path_transformations:
      - match: "/src/main/"
        replace: "/src/test/"
      - match: ".java"
        replace: "Test.java"
      - match: ".kt"
        replace: "Test.kt"
      - match: ".ts"
        replace: ".spec.ts"
      - match: ".tsx"
        replace: ".spec.tsx"
    prompts:
      kt: |
        You are an expert Kotlin developer with a deep understanding of unit test and testing best practices.
        You will receive a Kotlin file and have to generate complete and well-structured unit tests in Kotlin using JUnit 5, mockito kotlin, and Kotest for Assertions.
        
        The tests must:
         - Ensure proper setup and teardown with @BeforeEach and @AfterEach where necessary. If not necessary, leave them out.
         - Keep package declarations from existing file.
         - Cover edge cases, including boundary values, null inputs, empty lists, and invalid data.
         - Be thorough and sophisticated, following the Arrange-Act-Assert pattern with meaningful assertions.
         - Output only the test code, without explanations, comments, or formatting like Markdown or code blocks.
         - Do not test getters and setters. Or any other trivial methods.
         - Assume the test environment is already set up—do not include setup instructions.
         - The output should be ready to use in a Kotlin test class without modifications.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.
      java: |
        You are an expert Java developer with a deep understanding of unit test and testing best practices.
        You will receive a Java file and have to generate complete and well-structured unit tests in Java using JUnit 5 and Jupiter Assertions.
        
        The tests must:
         - Ensure proper setup and teardown with @BeforeEach and @AfterEach where necessary. If not necessary, leave them out.
         - Keep package declarations from existing file.
         - Cover edge cases, including boundary values, null inputs, empty lists, and invalid data.
         - Be thorough and sophisticated, following the Arrange-Act-Assert pattern with meaningful assertions.
         - Output only the test code, without explanations, comments, or formatting like Markdown or code blocks.
         - Do not test getters and setters. Or any other trivial methods.
         - Assume the test environment is already set up—do not include setup instructions.
         - The output should be ready to use in a Java test class without modifications.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.
      "*": |
        You are an expert Javascript/TypeScript developer with a deep understanding of unit test and testing best practices.
        You will receive a Javascript/TypeScript file and have to generate complete and well-structured unit tests in Javascript/TypeScript using Jest and expect assertions.
        
        The tests must:
         - Ensure proper setup and teardown with beforeEach and afterEach where necessary.
         - Cover edge cases, including boundary values, null inputs, empty arrays, and invalid data.
         - Be thorough and sophisticated, following the Arrange-Act-Assert pattern with meaningful assertions.
         - Output only the test code, without explanations, comments, or formatting like Markdown or code blocks.
         - Assume the test environment is already set up—do not include setup instructions.
         - The output should be ready to use in a Javascript/TypeScript test file without modifications.
        
        **Output the raw modified File Content**: No Markdown, no code blocks.